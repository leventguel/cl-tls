//#define TEST1
//#define TEST2
//#define TEST3
//#define TEST4
//#define TEST5
//#define TEST6
//#define CUSTOM_TEST

#include <wmmintrin.h>
#include <emmintrin.h>
#include <smmintrin.h>
#include <stdint.h>
#include <stdio.h>

#if !defined (ALIGN16)
# if defined (__GNUC__)
# define ALIGN16 __attribute__ ( (aligned (16)))
# else
# define ALIGN16 __declspec (align (16))
# endif
#endif
#ifndef CUSTOM_TEST
#ifndef TEST6
#ifndef TEST5
#ifndef TEST4
#ifndef TEST3
#ifndef TEST2
#ifndef TEST1
#define TEST1
#endif
#endif
#endif
#endif
#endif
#endif
#endif

typedef struct KEY_SCHEDULE{
  ALIGN16 uint8_t KEY[16*15];
  int nr;
}AES_KEY;

#define cpuid(func,ax,bx,cx,dx)						\
  __asm__ __volatile__ ("cpuid":					\
			"=a" (ax), "=b" (bx), "=c" (cx), "=d" (dx) : "a" (func));

extern void AES_GCM_encrypt(void*, void*, void*, void*, void*, uint64_t, uint64_t,
		       uint64_t, void*, uint64_t);

extern int AES_GCM_decrypt (const unsigned char *, unsigned char *, const unsigned char*, const unsigned char*,
			    unsigned char *, int, int, int, const unsigned char*,int);

extern void key_expansion_128(__m128i*, __m128i*, int, __m128i *);

extern void AES_128_Key_Expansion (const uint8_t *, AES_KEY *);

int Check_CPU_support_AES()
{
  unsigned int a,b,c,d;
  cpuid(1, a,b,c,d);
  return (c & 0x2000000);
}

/*****************************************************************************/
void print_m128i_with_string(char* string,__m128i data)
{
  unsigned char *pointer = (unsigned char*)&data;
  int i;
  printf("%-40s[0x",string);
  for (i=0; i<16; i++)
    printf("%02x",pointer[i]);
  printf("]\n");
}
void print_m128i_with_string_short(char* string,__m128i data,int length)
{
  unsigned char *pointer = (unsigned char*)&data;
  int i;
  printf("%-40s[0x",string);
  for (i=0; i<length; i++)
    printf("%02x",pointer[i]);
  printf("]\n");
}
/*****************************************************************************/
int main (){
  //The test vectors are taken from:
  //http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf
#ifdef TEST1
#define NBYTES 0
#define MBYTES 0
#define IBYTES 12
  ALIGN16 uint8_t K[16]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  ALIGN16 uint8_t P[NBYTES]={};
  ALIGN16 uint8_t IV[IBYTES]={0x00,0x00,0x00,0x00,0x00,0x00,
			      0x00,0x00,0x00,0x00,0x00,0x00};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={};
  ALIGN16 uint8_t EXPECTED_T[16]={0x58,0xe2,0xfc,0xce,0xfa,0x7e,0x30,0x61,
				  0x36,0x7f,0x1d,0x57,0xa4,0xe7,0x45,0x5a};
  ALIGN16 uint8_t A[MBYTES]={};
#endif

#ifdef TEST2
#define NBYTES 16
#define MBYTES 0
#define IBYTES 12
  ALIGN16 uint8_t K[16]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  ALIGN16 uint8_t P[NBYTES]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  ALIGN16 uint8_t IV[IBYTES]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			      0x00,0x00,0x00,0x00};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0x03,0x88,0xda,0xce,0x60,0xb6,0xa3,0x92,
				      0xf3,0x28,0xc2,0xb9,0x71,0xb2,0xfe,0x78};
  ALIGN16 uint8_t EXPECTED_T[16]={0xab,0x6e,0x47,0xd4,0x2c,0xec,0x13,0xbd,
				  0xf5,0x3a,0x67,0xb2,0x12,0x57,0xbd,0xdf};
  ALIGN16 uint8_t A[MBYTES]={};

#endif

#ifdef TEST3
#define NBYTES 64
#define MBYTES 0
#define IBYTES 12
  ALIGN16 uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,
			 0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
  ALIGN16 uint8_t P[NBYTES]={0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,
			     0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
			     0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,
			     0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
			     0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,
			     0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
			     0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,
			     0xba,0x63,0x7b,0x39,0x1a,0xaf,0xd2,0x55};
  ALIGN16 uint8_t IV[IBYTES]={0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,
			      0xde,0xca,0xf8,0x88};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0x42,0x83,0x1e,0xc2,0x21,0x77,0x74,0x24,
				      0x4b,0x72,0x21,0xb7,0x84,0xd0,0xd4,0x9c,
				      0xe3,0xaa,0x21,0x2f,0x2c,0x02,0xa4,0xe0,
				      0x35,0xc1,0x7e,0x23,0x29,0xac,0xa1,0x2e,
				      0x21,0xd5,0x14,0xb2,0x54,0x66,0x93,0x1c,
				      0x7d,0x8f,0x6a,0x5a,0xac,0x84,0xaa,0x05,
				      0x1b,0xa3,0x0b,0x39,0x6a,0x0a,0xac,0x97,
				      0x3d,0x58,0xe0,0x91,0x47,0x3f,0x59,0x85};
  ALIGN16 uint8_t EXPECTED_T[16]={0x4d,0x5c,0x2a,0xf3,0x27,0xcd,0x64,0xa6,
				  0x2c,0xf3,0x5a,0xbd,0x2b,0xa6,0xfa,0xb4};
  ALIGN16 uint8_t A[MBYTES]={};
#endif

#ifdef TEST4
#define NBYTES 60
#define MBYTES 20
#define IBYTES 12
  ALIGN16 uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,
			 0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
  ALIGN16 uint8_t P[NBYTES]={0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,
			     0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
			     0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,
			     0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
			     0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,
			     0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
			     0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,
			     0xba,0x63,0x7b,0x39};
  ALIGN16 uint8_t IV[IBYTES]={0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,
			      0xde,0xca,0xf8,0x88};
  ALIGN16 uint8_t A[MBYTES]={0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xab,0xad,0xda,0xd2};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0x42,0x83,0x1e,0xc2,0x21,0x77,0x74,0x24,
				      0x4b,0x72,0x21,0xb7,0x84,0xd0,0xd4,0x9c,
				      0xe3,0xaa,0x21,0x2f,0x2c,0x02,0xa4,0xe0,
				      0x35,0xc1,0x7e,0x23,0x29,0xac,0xa1,0x2e,
				      0x21,0xd5,0x14,0xb2,0x54,0x66,0x93,0x1c,
				      0x7d,0x8f,0x6a,0x5a,0xac,0x84,0xaa,0x05,
				      0x1b,0xa3,0x0b,0x39,0x6a,0x0a,0xac,0x97,
				      0x3d,0x58,0xe0,0x91};
  ALIGN16 uint8_t EXPECTED_T[16]={0x5b,0xc9,0x4f,0xbc,0x32,0x21,0xa5,0xdb,
				  0x94,0xfa,0xe9,0x5a,0xe7,0x12,0x1a,0x47};
#endif

#ifdef TEST5
#define NBYTES 60
#define MBYTES 20
#define IBYTES 8
  ALIGN16 uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,
			 0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
  ALIGN16 uint8_t P[NBYTES]={0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,
			     0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
			     0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,
			     0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
			     0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,
			     0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
			     0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,
			     0xba,0x63,0x7b,0x39};
  ALIGN16 uint8_t A[MBYTES]={0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xab,0xad,0xda,0xd2};
  ALIGN16 uint8_t IV[IBYTES]={0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0x61,0x35,0x3b,0x4c,0x28,0x06,0x93,0x4a,
				      0x77,0x7f,0xf5,0x1f,0xa2,0x2a,0x47,0x55,
				      0x69,0x9b,0x2a,0x71,0x4f,0xcd,0xc6,0xf8,
				      0x37,0x66,0xe5,0xf9,0x7b,0x6c,0x74,0x23,
				      0x73,0x80,0x69,0x00,0xe4,0x9f,0x24,0xb2,
				      0x2b,0x09,0x75,0x44,0xd4,0x89,0x6b,0x42,
				      0x49,0x89,0xb5,0xe1,0xeb,0xac,0x0f,0x07,
				      0xc2,0x3f,0x45,0x98};
  ALIGN16 uint8_t EXPECTED_T[16]={0x36,0x12,0xd2,0xe7,0x9e,0x3b,0x07,0x85,
				  0x56,0x1b,0xe1,0x4a,0xac,0xa2,0xfc,0xcb};

#endif

#ifdef TEST6
#define NBYTES 60
#define MBYTES 20
#define IBYTES 60
  ALIGN16 uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,
			 0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
  ALIGN16 uint8_t P[NBYTES]={0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,
			     0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
			     0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,
			     0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
			     0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,
			     0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
			     0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,
			     0xba,0x63,0x7b,0x39};
  ALIGN16 uint8_t A[MBYTES]={0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
			     0xab,0xad,0xda,0xd2};
  ALIGN16 uint8_t IV[IBYTES]={0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,
			      0x55,0x90,0x9c,0x5a,0xff,0x52,0x69,0xaa,
			      0x6a,0x7a,0x95,0x38,0x53,0x4f,0x7d,0xa1,
			      0xe4,0xc3,0x03,0xd2,0xa3,0x18,0xa7,0x28,
			      0xc3,0xc0,0xc9,0x51,0x56,0x80,0x95,0x39,
			      0xfc,0xf0,0xe2,0x42,0x9a,0x6b,0x52,0x54,
			      0x16,0xae,0xdb,0xf5,0xa0,0xde,0x6a,0x57,
			      0xa6,0x37,0xb3,0x9b};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0x8c,0xe2,0x49,0x98,0x62,0x56,0x15,0xb6,
				      0x03,0xa0,0x33,0xac,0xa1,0x3f,0xb8,0x94,
				      0xbe,0x91,0x12,0xa5,0xc3,0xa2,0x11,0xa8,
				      0xba,0x26,0x2a,0x3c,0xca,0x7e,0x2c,0xa7,
				      0x01,0xe4,0xa9,0xa4,0xfb,0xa4,0x3c,0x90,
				      0xcc,0xdc,0xb2,0x81,0xd4,0x8c,0x7c,0x6f,
				      0xd6,0x28,0x75,0xd2,0xac,0xa4,0x17,0x03,
				      0x4c,0x34,0xae,0xe5};
  ALIGN16 uint8_t EXPECTED_T[16]={0x61,0x9c,0xc5,0xae,0xff,0xfe,0x0b,0xfa,
				  0x46,0x2a,0xf4,0x3c,0x16,0x99,0xd0,0x50};
#endif

#ifdef CUSTOM_TEST
#ifndef NBLOCKS
#define NBLOCKS 64
#endif
#define NBYTES NBLOCKS*16
#define MBYTES 0
#define IBYTES 12
  ALIGN16 uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,
			 0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
  ALIGN16 uint8_t P[NBYTES]={0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,
			     0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
			     0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,
			     0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
			     0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,
			     0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
			     0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,
			     0xba,0x63,0x7b,0x39};
  ALIGN16 uint8_t A[MBYTES]={};
  ALIGN16 uint8_t
    IV[IBYTES]={0x93,0x13,0x22,0x5d,0xf8,0x84,0x06,0xe5,0x55,0x90,0x9c,0x5a};
  ALIGN16 uint8_t EXPECTED_C[NBYTES]={0};
  ALIGN16 uint8_t EXPECTED_T[16]={0};
#endif
  ALIGN16 uint8_t C[NBYTES],DECRYPTED_TEXT[NBYTES];
  __m128i T;
  int i,j,tag_correct=1,cipher_correct=1,decrypt_correct=1,decrypt_success;

  /* Verify AES support */
  if (Check_CPU_support_AES( ) == 0) {
    printf ("CPU does not support AES instructions. Bailing out. \n");
    exit (1);
  }
  else printf("CPU check passed. AES instructions are supported.\n\n");

  AES_KEY key;
  AES_128_Key_Expansion (K, &key);
  key.nr = 10;

  AES_GCM_encrypt(P, C, A, IV, &T, NBYTES, MBYTES, IBYTES, key.KEY, key.nr);

  decrypt_success = AES_GCM_decrypt(C, DECRYPTED_TEXT, A, IV, (unsigned char*)&T, NBYTES, MBYTES,
				    IBYTES, key.KEY, key.nr);
/******************************************************************************
Here we print the results of the test
*******************************************************************************/
  print_m128i_with_string("The Key:", *(__m128i*)K);
  printf("\n");

  for(i=0;i<IBYTES/16;i++)
    print_m128i_with_string("The IV:", ((__m128i*)IV)[i]);
  if(IBYTES%16)
    print_m128i_with_string_short("The IV:", ((__m128i*)IV)[i], IBYTES%16);
  printf("\n");

  for(i=0;i<MBYTES/16;i++)
    print_m128i_with_string("The header buffer:", ((__m128i*)A)[i]);
  if(MBYTES%16)
    print_m128i_with_string_short("The header buffer:", ((__m128i*)A)[i],
				  MBYTES%16);
  if(!MBYTES) printf("NONE\n");
  printf("\n");

  for(i=0;i<NBYTES/16;i++)
    print_m128i_with_string("The PLAINTEXT:", ((__m128i*)P)[i]);
  if(NBYTES%16)
    print_m128i_with_string_short("The PLAINTEXT:", ((__m128i*)P)[i], NBYTES%16);
  if(!NBYTES) printf("NONE\n");
  printf("\n");

  for(i=0;i<NBYTES/16;i++)
    print_m128i_with_string("The CIPHERTEXT:", ((__m128i*)C)[i]);
  if(NBYTES%16)
    print_m128i_with_string_short("The CIPHERTEXT:", ((__m128i*)C)[i],
				  NBYTES%16);
  if(!NBYTES) printf("NONE\n");
  printf("\n");
  print_m128i_with_string("The tag:",T);
  printf("\n");
  //Test correctness
  for(i=0;i<16;i++){
    if(((uint8_t*)&T)[i]!=EXPECTED_T[i]){
      tag_correct=0;
      break;
    }
  }
  for(i=0;i<NBYTES;i++){
    if(C[i]!=EXPECTED_C[i]){
      cipher_correct=0;
      break;
    }
  }
  for(i=0;i<NBYTES;i++){
    if(P[i]!=DECRYPTED_TEXT[i]){
      decrypt_correct=0;
      break;
    }
  }
#ifndef CUSTOM_TEST
  if(tag_correct)
    printf("The tag is equal to the expected tag.\n");
  else
    printf("The tag is NOT EQUAL to the expected tag!!!\n");
  if(cipher_correct)
    printf("The cipher text is equal to the expected cipher text.\n");
  else
    printf("The cipher text is NOT EQUAL to the expected cipher text!!!\n");
#endif
  if(decrypt_success)
    printf("Decryption succeeded.\n");
  else
    printf("Decryption FAILED!!!\n");
  if(decrypt_correct)
    printf("The decrypted text is equal to the original plaintext.\n");
  else
    printf("The decrypted text is NOT EQUAL to the original plaintext!!!\n");
}
